module instruction_mem(
	input[9:0] PC,
	input clock,
	output[31:0] Instruction
);
	reg[1023:0] Instructions[31:0];

	initial begin
		Instruction[0] = 32'b00000100000001000000000000100100; // addi $1 $0 9
		Instruction[1] = 32'b00000100000010000000000000110000; // addi $2 $0 12
		Instruction[2] = 32'b00000000010010001100001000000000; // add $3 $1 $2
		Instruction[3] = 32'b00010000010100000000000000110000; // slti $4 $1 12
		Instruction[4] = 32'b00010000010101000000000000011000; // slti $5 $1 6
		Instruction[5] = 32'b00000000010010011000001010100000; // slt $6 $1 $2  
		Instruction[6] = 32'b00000000010000011100001010100000; // slt $7 $1 $0
		Instruction[7] = 32'b00000000100001100000001000100000; // sub $8 $2 $1
		Instruction[8] = 32'b00000100001001000000000000111100; // addi $9 $0 15 (binary 1111)
		Instruction[9] = 32'b00000100001010000000000001101000; // addi $10 $0 26 (binary 111010)
		Instruction[10] = 32'b00000010011010101100001001000000; // and $11 $9 $10
		Instruction[11] = 32'b00000010011010110000001001010000; // or $12 $9 $10
		Instruction[12] = 32'b00001010011011000000000001101000; // andi $11 $9 26
		Instruction[13] = 32'b00001110011100000000000001101000; // ori $12 $9 26
		Instruction[14] = 32'b00010100000010000000000001000100; // li $2 17
		Instruction[15] = 32'b10101100000010000000000001100000; // sw $2 24($0)
		Instruction[16] = 32'b10001100001000000000000001100000; // lw $12 24($0)
		Instruction[17] = 32'b11111100010010000000000000000000; // mult $1 $2
		Instruction[18] = 32'b10101100001110000000000011001000; // sw $14 50($0) (hi register)
		Instruction[19] = 32'b10101100001111000000000010100000; // sw $15 40($0) (lo register)
		
	end



endmodule